/***********************************************************************
*
* Parse - SLR(1) parser
*
* This routine interprets the parse tables, generated by CHAT, to
* perform the SLR(1) parsing actions.
* Based on Aho and Ullman's parser in "Principles of Compiler Design".
* A lexical scanner is also included to present the input expression
* to the parser as a stream of tokens.
*
* External routines supplied by the user:
*   Parse_Error (error, state);
*
* Files included into the parser:
*   asm7070.sem    - From CHAT
*   asm7070.ptb    - From CHAT
*   asm7070.err    - From CHAT
*   asm7070.tok    - From CHAT
*
*   errors.h      - User produced, Scanner errors
*   scanner.h     - User produced, Scanner actions
*   stables.h     - User produced, Scanner state tables
*
* External State machine tables:
*   parsetable    - From CHAT, in asm7070.ptb
*   gototable     - From CHAT, in asm7070.ptb
*   chartable     - User produced, in stables.h
*   scantable     - User produced, in stables.h
*
* Changes:
*   LongAgo    DGP   Original.
*
***********************************************************************/
 
/* System includes */
 
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

#ifndef TRUE
#define TRUE 1
#endif
 
#ifndef FALSE
#define FALSE 0
#endif
 
 
/* Scanner actions */
 
#define NULL_ACTION     0x00
#define ERROR_ACTION    0x01
#define BACK_ACTION     0x02
#define MOVE_ACTION     0x04
#define EAT_ACTION      0x08
#define BUILD_ACTION    0x10
 
/* Parser actions */
 
#define SHIFT_ACTION    0
#define REDUCE_ACTION   1
 
/* Local types */
 
#include "asmdef.h"
#include "asmdmem.h"
#include "errors.h"

/* Stack element */
 
typedef struct selement
{
   struct selement *link;
   pstate   state;
   tokval   svalue;
   char     cvalue[TOKENLEN+2];
} selement_t ;
 
/* Parser tables */
 
#include "asm7070.ptb"
 
/* Scanner tables */
 
#include "stables.h"
 
/* Local static variables */
 
static selement_t *stack;
static selement_t *frees = NULL;
static int err_flag;
static int defer;
static int retsize;
 
/* External variables */
 
extern int pc;
extern int symbolcount;
extern int exprtype;
extern int rightmargin;
extern int linenum;
extern int genxref;
extern int inpass;
extern int errnum;
extern int radix;
extern int pgmlength;

extern char inbuf[MAXLINE];
extern char errline[10][120];

extern SymNode *symbols[MAXSYMBOLS];
 
/***********************************************************************
*
* POP - POP parser stack
* This routine pops parse states and token values from the parse stack
* when a reduction is recognized. Put pop'd elements onto a free stack
* for speed.
*
***********************************************************************/

static void
Pop (int h)
{
   selement_t *stemp;
   int i;
 
#ifdef DEBUG_PARSE
   fprintf (stderr, "Pop: h = %d\n", h);
#endif

   for (i=0; i<h; i++)
   {
      if (stack == NULL) break;
      else
      {
         stemp = stack->link;
         stack->link = frees;
         frees = stack;
         stack = stemp;
      }
   } /* of for */
 
} /* Pop */
 
/***********************************************************************
*
* PUSH - Push parser stack
* This routine pushes a parse state and token value onto the parse
* stack. Allocate new elements if free stack is empty.
*
***********************************************************************/

static void
Push (pstate s,
      tokval v,
      char *cv)
{
   selement_t *stemp;
 
#ifdef DEBUG_PARSE
   fprintf (stderr,
	 "Push: state = %d, tokval = %d, toksym = '%s', \n",
	   s, v, cv ? cv : "null");
#endif

   if (frees == NULL)
   {
      stemp = (selement_t *)DBG_MEMGET (sizeof(selement_t));
      if (stemp == NULL)
      {
         Parse_Error (MEM_OVERFLOW, STACK_OVERFLOW, defer);
         return;
      }
   }
   else
   {
      stemp = frees;
      frees = stemp->link;
   }
 
   memset (stemp, '\0', sizeof(selement_t));
   stemp->state = s;
   stemp->svalue = v;
   if (cv)
   {
      if (strlen(cv) > TOKENLEN)
      {
#ifdef DEBUGMALLOCS
         fprintf (stderr, "Push: token cv too long: cv = %s\n", cv);
#endif
         cv[TOKENLEN] = '\0';
      }
      strcpy (stemp->cvalue, cv);
   }
   stemp->link  = stack;
   stack = stemp;
 
} /* Push */
 
/***********************************************************************
*
* Stkval - Get stack value
* This routine returns the value of a stack element given its position.
*
***********************************************************************/

static tokval
Stkval (int depth)
{
   selement_t *stemp;
   int i;
 
#ifdef DEBUG_INTERP
   fprintf (stderr, "Stkval: depth = %d\n", depth);
#endif

   stemp = stack; /* Find stack element */
   for (i=2; i <= depth; i++)
   {
      stemp = stemp->link;
      if (stemp == NULL) return (VALUEZERO);
   }
#ifdef DEBUG_INTERP
   fprintf (stderr, "   value = %d\n", stemp->svalue);
#endif
   return (stemp->svalue);
 
} /* Stkval */
 
/***********************************************************************
*
* CStkval - Get char stack value
* This routine returns a pointer to the character value of a stack
* element given its position.
*
***********************************************************************/

static char *
CStkval (int depth)
{
   selement_t *stemp;
   int i;
 
#ifdef DEBUG_INTERP
   fprintf (stderr, "CStkval: depth = %d\n", depth);
#endif

   stemp = stack; /* Find stack element */
   for (i=2; i <= depth; i++)
   {
      stemp = stemp->link;
      if (stemp == NULL) return (NULL);
   }
#ifdef DEBUG_INTERP
   fprintf (stderr, "   value = '%s'\n", stemp->cvalue);
#endif
   return (stemp->cvalue);
 
} /* CStkval */
 
/***********************************************************************
*
* TOP - Get current parse state
* This routine return the parse state from the top element of the
* parse stack.
*
***********************************************************************/

static pstate
Top (void)
{
   return (stack->state);
}
 
/***********************************************************************
*
* Interpret - Interpret syntactical reduction
* This routine adds the semantic interpretation to the recognition of
* syntactical reductions.
*
***********************************************************************/

static tokval
Interpret (pstate r, int *pos, int *ix)
{
   tokval value;
   char symbol[TOKENLEN+2];
 
#ifdef DEBUG_INTERP
   fprintf (stderr, "Interpret: red = %d\n", r);
#endif
 
   value = VALUEZERO;
   symbol[0] = '\0';
   switch (r)
   {
 
   /* Get the generated semantic actions */
#include "asm7070.sem"
 
   default:
      value = Stkval(1);
   }
 
   return (value);
 
} /* Interp */
 
/***********************************************************************
*
* Scanner - Lexical scanner
* This routine is a table driven scanner used to lexically analyze
* source input. Scanner is called whenever the parser needs the next
* token in the input stream. The scanner is implemented as a finite
* state machine.
*
***********************************************************************/

toktyp
Scanner (char expr[], int *ndx, tokval *svalue, int *pos, int *ix,
	 char *toksym, char *term, int defr)
{
   tokval dignum, value;
   int    i, sdx;
   uint16 sa, *pt;
   toktyp token;
   uint8  chr, next, action;
   uint8  select;
   uint8  current_state; /* Scanner current state */
   char   lachar, latran; /* Look ahead character */
   char   symbol[TOKENLEN+2]; /* Collected symbol */
 
#ifdef DEBUG_SCAN
   fprintf (stderr, "Scanner entered:\n");
#endif
 
   defer = defr;
   value = VALUEZERO; /* Initialization */
   sdx = 0;
   symbol[sdx] = '\0';

   current_state = ADDREXPRSTART;
 
   do
   {
 
      lachar = expr[*ndx]; /* Get current input char */
      latran = chartable[lachar]; /* Classify the character */

#ifdef DEBUG_SCAN
      fprintf (stderr, " cs = %d, lachar = %02x, latran = %d\n",
	      current_state, lachar, latran);
#endif
 
      dignum = VALUEZERO;
      if (isdigit(lachar)) /* Convert digit to number */
         dignum = lachar - '0';
#ifdef DEBUG_SCAN
      fprintf (stderr, " dignum = %d\n", dignum);
#endif
 
      /* Find state transition given current state and input character */
 
      pt = (uint16 *)scantable[current_state-1];
 
      for (i=0 ;; i++)
      {
 
         sa = *pt++;
         action = sa & 31;
         next = (sa >> 5) & 63;
         chr = (sa >> 11) & 31;

 
#ifdef DEBUG_SCAN
         fprintf (stderr, " Si = %d, a = %02x, n = %d, c = %d\n",
		 i, action, next, chr);
#endif
 
         if ((chr == latran) || (chr == 31)) /* State transition fnd. */
	 {
 
            /* Perform the scan action for this transition */
 
            if (ERROR_ACTION & action) /* Error, terminate scan */
	    {
#ifdef DEBUG_SCAN
               fprintf (stderr, "   ERROR: \n");
#endif
               Parse_Error (SCAN_ERROR, current_state, defer);
               return (0);
            }
 
            if (BACK_ACTION & action) /* Back up in input stream */
	    {
#ifdef DEBUG_SCAN
               fprintf (stderr, "   BACK:\n");
#endif
               *ndx = *ndx - 1;
            }
 
            if (EAT_ACTION & action) /* Eat (ignore) character */
	    {
#ifdef DEBUG_SCAN
               fprintf (stderr, "   EAT:\n");
#endif
               *ndx = *ndx + 1;
            }
 
            if (MOVE_ACTION & action) /* Move to symbol */
	    {
#ifdef DEBUG_SCAN
               fprintf (stderr, "   MOVE: \n");
#endif
               if (sdx < TOKENLEN)
	       {
		  symbol[sdx] = lachar;
                  sdx ++;
                  symbol[sdx] = '\0';
               }
            }
 
            if (BUILD_ACTION & action) /* Token found process it */
	    {
	       *term = lachar;
               if (next == 0) select = current_state;
               else           select = next;
#ifdef DEBUG_SCAN
               fprintf (stderr, "   BUILD: select = %d\n", select);
#endif
               switch (select)
	       {
 
               /* Get the scanner actions */
#include "scanner.h"
 
               }
            }
 
            current_state = next;      /* Goto new scan state */
            break;
 
         }
      }
 
   } while (current_state != 0);
 
#ifdef DEBUG_SCAN
   fprintf (stderr, " token = %d, val = %d, symbol = '%s'\n",
	   token, value,
	   symbol[0] ? symbol : "null");
#endif
 
   *svalue = value;
   strcpy (toksym, symbol);
 
   return (token);
 
} /* Scanner */
 
/***********************************************************************
*
* Parser - SLR(1) parser
* This routine interprets the parse tables to perform the SLR(1)
* parsing actions.
*
***********************************************************************/

tokval
Parser (char *expr, int *eindex, int *pos, int *ix, int rsize, int defr)
{
   uint16 *pt, *gp;
   tokval value, rvalue;
   int    i, j, index;
   uint16 pa, tok, act;
   toktyp token;
   pstate current_state, c_s;
   pstate next, crnt;
   pstate sr;
   char   tterm;
   char   toksym[TOKENLEN+2];
 
#ifdef DEBUG_PARSE
   fprintf (stderr, "Parse Entered:\n");
#endif
 
   defer = defr;
   retsize = rsize;
   index = 0;
   current_state = 1;
   stack = NULL;
   err_flag = FALSE;
   toksym[0] = '\0';
 
   Push (current_state, VALUEZERO, NULL);

   /* Get look ahead input token */
   token = Scanner (expr, &index, &value, pos, ix, toksym, &tterm, defer);
   if (token == 0) return(0);
 
   do
   {
 
      /* Get action entry for current state, look ahead token */
 
      pt = (uint16 *)parsetable[current_state-1];
 
      for (i=0 ;; i++)
      {
 
         pa = *pt++;
         tok = pa & 127;
         act = (pa >> 7) & 1;
         sr = (pa >> 8) & 255;
 
#ifdef DEBUG_PARSE
         fprintf (stderr, " Pi = %d, token = %d, t = %d, a = %d, sr = %d\n",
		 i, token, tok, act, sr);
#endif
 
         if ((tok == 127) || (tok == token))
	 {
 
            /* State action found - do error, shift or reduce action */
 
            if ((sr == 255) || err_flag)
	    {
               if (! err_flag) /* Error processor - user defined */
                  Parse_Error (PARSE_ERROR, current_state, defer);
               Pop (1000);
	       *eindex = index;
               return (value);
            }
 
            if (act == SHIFT_ACTION)
	    {
 
#ifdef DEBUG_PARSE
               fprintf (stderr, " Shift, value = %d\n", value);
#endif
 
               Push (sr, value, toksym);
               token = Scanner (expr, &index, &value, pos, ix, toksym, &tterm,
				defer);
	       if (token == 0) return(0);
            }
 
            else /* REDUCE_ACTION */
	    {
               rvalue = Interpret (sr, pos, ix);
 
#ifdef DEBUG_PARSE
               fprintf (stderr, " Reduce, sr = %d, rvalue = %d\n", sr, rvalue);
               fprintf (" Handle = %d\n", gototable[sr-1].handle);
#endif
 
               Pop (gototable[sr-1].handle);
               c_s = Top();
 
#ifdef DEBUG_PARSE
               fprintf (stderr, " TOP-state = %d\n", c_s);
#endif
 
               /* Use goto tables to get next state */
 
               gp = (uint16 *) gototable[sr-1].go;
 
               for (j=0 ;; j++)
	       {
 
                  pa = *gp++;
                  crnt = pa & 255;
                  next = (pa >> 8) & 255;
 
#ifdef DEBUG_PARSE
                  fprintf (stderr, " j = %d, crnt = %d, next = %d\n",
			  j, crnt, next);
#endif
 
                  if ((crnt == c_s) || (crnt == 255))
		  {
                     Push (next, rvalue, NULL);
                     break;
                  }
 
               } /* for j */
 
            }
            break;
         }
 
      } /* for i */
 
      current_state = Top();
 
#ifdef DEBUG_PARSE
      fprintf (stderr, " Cursta = %d\n", current_state);
#endif
 
   } while (current_state != 0); /* Until input is accepted */
 
   Pop (50); /* Purge stack of possible leftovers */
 
   *eindex = index;

   return (rvalue);
 
} /* Parser */
