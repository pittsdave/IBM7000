ADMIN     R *  ADMINISTRATIVE PRIVLEGED COMMANDS
          R *
          R * WRITTEN BY R. A. ROACH    MARCH 1969
          R *
          R * ONLY M1416 USERS WITH EITHER PATCH PRIVILEGES OR
          R * 16 PRIVILEGES MAY HAVE ACCESS TO ADMIN'S FUNCTIONS.
          R * (EXCEPT THE OPERATOR (C33 960) MAY USE HELLO.)
          R *
          R * FOR A LIST OF THE AVAILABLE FUNCTIONS:
          R *          ADMIN (HELP)
          R *
          R * FOR THE CORRECT USAGE OF A FUNCTION:
          R *          ADMIN FUNCT (HELP)
          R *
          R *  WHEN 'USER' IS A POSSIBLE ARGUMENT, IT MAY
          R *  BE SPECIFIED IN ANY OF THREE DIFFERENT WAYS:
          R *   1.  NONE - ASSUMES CURRENT USER
          R *   2.  PROB PROG
          R *   3.  LINE NO.
          R *
          R *
          R * LOADING INSTRUCTIONS:
          R *   LAED NCLOAD ADMIN ADUTIL DELTEM (SRCH) XLIBE
          R *
          R *
          R *  CONSTANTS AND STORAGE DECLARATIONS
          R *
            DIMENSION B1(0), B2(0), B3(0), B4(0), B5(0)
            DIMENSION WHO(3), ME(1), PROB(1), COMBUF(20)
            DIMENSION PROBN(0), PROGN(0), TUCARD(27)
            DIMENSION TEMP(7)
          R *
            EQUIVALENCE (PROG,PROB(1)), (SLPCMD,FENCE)
            EQUIVALENCE (T0,TEMP(0)), (T1,TEMP(1)), (T2,TEMP(2)),
          1  (T3,TEMP(3))
            EQUIVALENCE (T4,TEMP(4)), (T5,TEMP(5)), (T6,TEMP(6)),
          1  (T7,TEMP(7))
          R *
            VECTOR VALUES STAR  = $     *$
            VECTOR VALUES M0 = -0
            VECTOR VALUES M1 = -1
            VECTOR VALUES M2 = -2
            VECTOR VALUES M = 0
            VECTOR VALUES TEMP(0)...TEMP(7) = 0
          R *
            VECTOR VALUES MFD    = $M.F.D.$
            VECTOR VALUES FILE   = $(FILE)$
            VECTOR VALUES M1416  = $ M1416$
            VECTOR VALUES CMFL02 = $CMFL02$
            VECTOR VALUES TU = $TIMUSD$
            VECTOR VALUES TA = $TIMACC$
            VECTOR VALUES R = $R$
            VECTOR VALUES W = $W$
            VECTOR VALUES N = $N$
            VECTOR VALUES ALL    = $ALL   $
            VECTOR VALUES USER   = $USER  $
            VECTOR VALUES COMMND = $COMMND$
            VECTOR VALUES PROBN  = $PROBN $
            VECTOR VALUES PROGN  = $PROGN $
            VECTOR VALUES UNAME  = $UNAME $
            VECTOR VALUES USROPT = $USROPT$
            VECTOR VALUES URCODE = $URCODE$
            VECTOR VALUES RCODE  = $RCODE $
            VECTOR VALUES NINTBT = $NINTBT$
            VECTOR VALUES RCALBT = $RCALBT$
            VECTOR VALUES RPROBT = $RPROBT$
            VECTOR VALUES RPRVBT = $RPRVBT$
            VECTOR VALUES RPATBT = $RPATBT$
            VECTOR VALUES STRTIM = $STRTIM$
            VECTOR VALUES WRKTIM = $WRKTIM$
            VECTOR VALUES TIMNOW = $TIMNOW$
            VECTOR VALUES UNITID = $UNITID$
            VECTOR VALUES TAU1   = $TAU1  $
            VECTOR VALUES TAU5   = $TAU5  $
            VECTOR VALUES ADOPT  = $ADOPT $
            VECTOR VALUES MESGPT = $MESGPT$
            VECTOR VALUES SYSMSG = $SYSMSG$
            VECTOR VALUES FSTST  = $FS.TST$
            VECTOR VALUES SAVING = $SAVING$
          R *
          R *
            VECTOR VALUES HELP = $(HELP)$
            VECTOR VALUES X = $'X$
            VECTOR VALUES ADMIN = $ 'UADMIN '8$
            VECTOR VALUES RED = $'R'8$
            VECTOR VALUES BLACK = $'B'8$
            VECTOR VALUES ON = $ ON 'X$
            VECTOR VALUES BL = $ '8$
            VECTOR VALUES KEY22 = 000000K
          R *  ... CHANGE TO 20000K TO MAKE EFFECTIVE ...
            VECTOR VALUES NULLS = 575757575757K
          R *
            VECTOR VALUES SLPCMD = 777777777777K, $YES$, $.$
          R *
          R *
          R *
          R *  INITIALIZATION
          R *
            NORMAL MODE IS INTEGER
            WHOAMI.(WHO(3)...4)
            ATTNAM.(ME(1)...2)
            GETTM.(DATE,TIME)
            FERRTN.(IOERR)
            SETBRK.(OUT)
            PCTL.(1)
          R *
            USER = GLOC.(COMMON.(USER))
          R *
          R *  SET COMMAND NAME TO ZERO TO HIDE IT -
            SLOC.(0,COMMON.(COMMND)+USER)
          R *
            RCODE = GLOC.(COMMON.(RCODE)+USER)
            RPATBT = COMMON.(RPATBT)
            RCALBT = COMMON.(RCALBT)
            RPROBT = COMMON.(RPROBT)
            RPRVBT = COMMON.(RPRVBT)
          R *
            NINTBT = COMMON.(NINTBT).LS.18
            USROPT = COMMON.(USROPT)+USER
            N = COMMON.(N)
          R *
            GCLS.(COMBUF,0)
            WHENEVER COMBUF.E.$ ADMIN$, M = 1
          R *
          R *  TEST FOR OK USER
          R *
            WHENEVER COMBUF(M).E.$ HELLO$ .AND. WHO(3).E.$ C0033$ .AND.
          1  WHO(2) .E. $   960$, TRANSFER TO USEROK
            BITS = RCALBT.V.RPROBT.V.RPRVBT
            WHENEVER WHO(3).E.M1416 .AND. (RCODE.A.BITS.E.BITS .OR.
          1   RCODE .A. RPATBT.E.RPATBT), TRANSFER TO USEROK
          R *
          R *  OTHERWISE, PRETEND THAT ADMIN DOESN'T EXIST
            TSK.
          R *
USEROK      WHENEVER COMBUF(M).E.HELP .OR. COMBUF(M).E.FENCE
              PRFULL.($'* 'R'1CORRECT USAGE IS:'B'*'*'8$,
          1   $  '5ADMIN FUNCTION ARGS'*'*'8$,
          2   $WHERE THE FUNCTION MAY BE ANY OF THE FOLLOWING:'*'8$)
          R *
              PRFULL.(FMT1...100,FMT2...100)
          R *
              VECTOR VALUES FMT1 =
          1  $'6CNDRLA - CLEARS ALL PRESENT USERS TAU VECTORS (36)'*'8$,
          2  $'4COPY   - COPY ACCOUNTING FILES FROM '4CMFL02 (10)'*'8$,
          3  $'6DELALL - DELETES ALL FILES FROM A DIRECTORY'*'8$,
          4  $'6DELTEM - DELETES TEMPORARY FILES FROM A DIRECTORY'*'8$,
          5  $'5ERASE  - ELIMINATES A FILE DIRECTORY'*'8$,
          6  $'5HELLO  - MODIFIES DIALUP MESSAGE'*'8$,
          7  $'5INPUT  - ENTER A LINE INTO A USER''S INPUT BUFFER'*'8$,
          8  $'4KILL   - LOGS A USER OUT'*'8$,
          9  $'5MONTH  - UPDATE AND RESET TIMUSD (36)'*'8$,777777777777K
          R *
              VECTOR VALUES FMT2 =
          1  $'5PATCH  - PATCHES CORE '1A (20)'*'8$,
          2  $'2PB     - ASSIGNS A PERCENTAGE TO A USER'*'8$,
          3  $'6PRNTON - PRINT MESSAGE ONLINE'*'8$,
          4  $'6RDTIMU - PRINT TIME USED BY A USER'*'8$,
          5  $'6SETTAU - RESET A '3TAU VECTOR OF A USER'*'8$,
          6  $'3SPY    - SPY ON A USER'*'8$,
          7  $'6SQZUFD - COMPACT A 'UU.F.D.'L'*'8$,
          8  $'6UPATCH - PATCH ARRAY ENTRY OF PRESENT USER (20)'*'8$,
          9  $'6UPDATE - UPDATE '4CMFL02 WITH ACCOUNTING FILES(10)'*'8$,
          0  $'5WRITE  - WRITE A MESSAGE AT A USER'*'8$,777777777777K
          R *
              PRFULL.($'1FOR THE CORRECT USAGE OF A FUNCTION:'*'*'8$,
          1  $     '5ADMIN FUNCT 'U(HELP)$)
          R *
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            CNDRLA
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
CNDRLA    R *  RESET THE TAU VECTORS(USED) OF ALL USERS LOGGED IN.
          R *
          R *  USAGE:  ADMIN CNDRLA
          R *
            EQUIVALENCE (T0,MAXI), (T6,TAULOC)
          R *
            OR WHENEVER COMBUF(M) .E. $CNDRLA$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(ADMIN...2,CURCOM.(0))
              OTHERWISE
                WHENEVER COMBUF(M).NE.FENCE, TRANSFER TO ERR1
                CHKPRV.(BITS.V.RPATBT)
                MAXI = 5 * (N+1)
                TAULOC = COMMON.(TAU5)
          R *
                PCTL.(3)
                PRFULL.(X,WHO(3)...M2,$ RESETTING TIMUSD.$)
                PCTL.(1)
          R *
          R *      M1416 4301 RESETTING TIMUSD.
          R *
                NONINT.
                THROUGH CND1, FOR I = 0,1,I.G.MAXI
CND1            SLOC.(GLOC.(TAULOC+I).A.77776K7,TAULOC+I)
                INT.
              END OF CONDITIONAL
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            COPY
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
COPY      R * COPY AN ACCOUNTING FILE FROM M1416 CMFL02
          R *
          R * USAGE:  ADMIN COPY N1 -N2- -N3- -N4-
          R *
            EQUIVALENCE (T0,N1), (T1,N2), (T2,N3), (T3,N4), (T7,MODE)
          R *
            OR WHENEVER COMBUF(M) .E. $  COPY$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(ADMIN...2,CURCOM.(0),$ N1 -N2- -N3- -N4-$)
              OTHERWISE
                N1 = COMBUF(M)
                N2 = COMBUF(M+1)
                N3 = COMBUF(M+2)
                N4 = COMBUF(M+3)
                WHENEVER N2 .E. FENCE
                  N2 = TA
                  N3 = N1
                  N4 = N2
                OR WHENEVER N3 .E. FENCE
                  N3 = N1
                  N4 = N2
                OR WHENEVER N4 .E. FENCE
                  N4 = N2
                OR WHENEVER N1 .E. FENCE
                  TRANSFER TO ERR2
                OR WHENEVER COMBUF(M+4).NE. FENCE
                  M = M+4
                  TRANSFER TO ERR1
                END OF CONDITIONAL
                M = M+4
                WHENEVER ME(1).E.M1416 .AND. ME.E.CMFL02 .AND.
          1          N3.E.N1 .AND. N4.E.N2, TRANSFER TO ERR0
                CHKPRV.(RPRVBT)
          R *
          R       ... GET RID OF PREVIOUS DATE TIME
                UNLINK.(DATE,TIME,NULL.)
                CHFILE.(DATE,TIME,1,M0,M0,NULL.)
                DELFIL.(DATE,TIME,NULL.)
                OPEN.(W,DATE,TIME,120K)
                GETBUF.(B1,432)
                GETBUF.(B2,432)
                GETBUF.(B3,432)
                GETBUF.(B4,432)
                BUFFER.(DATE,TIME,B4(B4+432)...432)
                ATTACH.(M1416,CMFL02)
                NONINT.
                OPEN.(R,N1,N2)
                COPY.(N1,N2,DATE,TIME,B1(B1+432),B2(B2+432),B3(B3+432),
          1           432,IOERR)
                CLOSE.(N1,N2)
                INT.
                CLOSE.(DATE,TIME)
                ATTACH.(ME(1),ME)
                MODE = 124K
                FSTATE.(N3,N4,TUCARD(1)...2,CPY1)
                MODE = TUCARD.A.777K
CPY1            UNLINK.(N3,N4,NULL.)
                CHFILE.(N3,N4,1,M0,M0,NULL.)
                DELFIL.(N3,N4,NULL.)
                CHFILE.(DATE,TIME,MODE,N3,N4)
              END OF CONDITIONAL
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            DELALL
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
DELALL    R * DELETE ALL OF A USER'S FILES AND HIS UFD.
          R *
          R *  USAGE:   ADMIN DELALL USER
          R *
            OR WHENEVER COMBUF(M) .E. $DELALL$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(ADMIN...2,CURCOM.(0),$ 'LUSER$)
              OTHERWISE
                GETUSR.(ERR3,DEL0,ERR5)
DEL0            ATTACH.(PROB,PROG)
                DELALL.
                TRANSFER TO ERASE0
              END OF CONDITIONAL
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            DELTEM
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
DELTEM    R * DELETE TEMPORARY FILES OF A USER
          R *
          R *  USAGE:  ADMIN DELTEM USER
          R *
            OR WHENEVER COMBUF(M) .E. $DELTEM$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(ADMIN...2,CURCOM.(0),$ 'LUSER$)
              OTHERWISE
                GETUSR.(ERR3,DEL1,ERR5)
DEL1            ATTACH.(PROB,PROG)
                DELTEM.
              END OF CONDITIONAL
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            ERASE
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
ERASE     R * ERASE A UFD FROM THE SYSTEM
          R *
          R *    USAGE:  ADMIN ERASE USER
          R *
            OR WHENEVER COMBUF(M) .E. $ ERASE$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(ADMIN...2,CURCOM.(0),$ 'LUSER$)
              OTHERWISE
                GETUSR.(ERR3,ERASE0,ERR5)
ERASE0          ATTACH.(PROB,PROG)
                ALLOT.(1,0,0)
                ALLOT.(2,0,0)
                ALLOT.(3,0,0)
                DELMFD.(PROB,PROG)
              END OF CONDITIONAL
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            HELLO
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
HELLO     R * UPDATE/RESET THE DIALUP MESSAGE
          R *
          R * USAGE: ADMIN HELLO ARG
          R *
          R * WHERE ARG MAY BE:
          R *   1. NOTHING - SETS NEXT COMEDOWN MESSAGE
          R *   2. 'NEWMES' - ALLOWS NEW MESSAGE TO BE TYPED IN
          R *   3. 'RESET' - RESETS MESSAGE SWITCH TO KEEP IT FROM BEING
          R *                 PRINTED UPON A DIALUP.
          R *
            EQUIVALENCE (HELMES(13),TUCARD(13))
            VECTOR VALUES HELMES = $NEXT COMEDOW$
            VECTOR VALUES HELMES(2) = 453560575757K
          R *
            OR WHENEVER COMBUF(M) .E. $ HELLO$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(FMT4...100)
                VECTOR VALUES FMT4 = $ 'UADMIN HELLO 'LARG'*'8$,
          1   $WHERE '=ARG'= MAY BE:'*'8$,
          2   $  1.   NONE   - SETS 'U'=NEXT COMDOWN:'='L MESSAGE'*'8$,
          3   $  2. '='6NEWMES'= - ALLOWS COMPLETELY NEW MESSAGE'*'8$,
          4   $  3. '='5RESET'=  - RESETS MESSAGE SWITCH$,777777777777K
          R *
              OTHERWISE
                MESGPT = COMMON.(MESGPT)
                SYSMSG = COMMON.(SYSMSG)
                WHENEVER COMBUF(M) .E. $NEWMES$
                  PRFULA.($'R'1TYPE: 'B'8$)
                  RDFLXC.(HELMES,84)
                OR WHENEVER COMBUF(M) .E. $ RESET$
                  SLOC.(0,MESGPT)
                  TRANSFER TO OUT
                OR WHENEVER COMBUF(M) .E. FENCE
                  PRFULA.($'R'X$,HELMES...3,$'B'8$)
                  RDFLXC.(HELMES(3),66)
                OTHERWISE
                  TRANSFER TO ERR1
                END OF CONDITIONAL
                THROUGH HEL1, FOR I = 0,1,I.G.13
HEL1            SLOC.(HELMES(I),SYSMSG+I)
                SLOC.(16K6.V.SYSMSG,MESGPT)
              END OF CONDITIONAL
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            INPUT
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
INPUT     R * INPUT A LINE TO A USER'S INPUT BUFFER
          R *
          R * USAGE: ADMIN INPUT USER -(DRMT)-
          R *
            DIMENSION INPMES(14)
            EQUIVALENCE (INPMES,TACARD), (DRMTSW,T0)
            BOOLEAN DRMTSW
          R *
            OR WHENEVER COMBUF(M) .E. $ INPUT$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(ADMIN...2,CURCOM.(0),$ '4USER -(DRMT)-$)
              OTHERWISE
                GETUSR.(ERR3,ERR4,INP1)
INP1            WHENEVER COMBUF(M) .E. $(DRMT)$
                  DRMTSW = 1B
                OR WHENEVER COMBUF(M) .E. FENCE
                  DRMTSW = 0B
                OTHERWISE
                  TRANSFER TO ERR1
                END OF CONDITIONAL
                PRFULA.($'R'1TYPE: 'B'8$)
                RDFLXA.(INPMES(14)...14)
                NONINT.
                WHENEVER DRMTSW
                  RSSWB.(USR)
                  SCHEDL.(2,USR,1)
                END OF CONDITIONAL
                ENTLIN.(INPMES(14)...14,USR,ERR7)
                INT.
              END OF CONDITIONAL
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            KILL
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
KILL      R * LOG A USER OUT
          R *
          R * USAGE: ADMIN KILL USER
          R *
            OR WHENEVER COMBUF(M) .E. $  KILL$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(ADMIN...2,CURCOM.(0),$ 'LUSER$)
              OTHERWISE
                GETUSR.(ERR3,ERR4,ERR5)
                WHENEVER COMBUF(M).NE.FENCE, TRANSFER TO ERR1
                PCTL.(3)
                PRFULL.(X,WHO(3)...M2,ON,WHO,$ KILLING'X$,
          1           PROB...2,$.$)
                PCTL.(1)
          R *
          R *   M1416 4301 0N 800251 KILLING M1416 9324.
          R *
                KILL.(USR)
              END OF CONDITIONAL
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            MONTH
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
MONTH     R * UPDATE TIMUSD AND RESET TAU VECTORS
          R *
          R * USAGE:   ADMIN MONTH -NAME1- -NAME2-
          R *
          R * E'E (T0,N1), (T1,N2), (TUCARD(8),LENGTH), (T6,TAULOC)
            EQUIVALENCE (T7,LEN)
            EQUIVALENCE (TUCARD(2),DAYTIM), (TUCARD(1),DATELU)
          R *
            OR WHENEVER COMBUF(M) .E. $ MONTH$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.($ 'UADMIN MONTH 'L-NAME1- -NAME2-$)
              OTHERWISE
                CHKPRV.(BITS.V.RPATBT)
                N1 = COMBUF(M)
                N2 = COMBUF(M+1)
                WHENEVER N1 .E. FENCE
                  N1 = TU
                  N2 = TA
                OR WHENEVER N2 .E. FENCE
                  N2 = TA
                OR WHENEVER COMBUF(M+2) .NE. FENCE
                  TRANSFER TO ERR1
                END OF CONDITIONAL
                LEN = 5*(N+1)
                TAULOC = COMMON.(TAU5)
                GETBUF.(B5,LEN)
                ATTACH.(M1416,CMFL02)
                FSTATE.(TU,TA,LENGTH...8)
          R *
                PCTL.(3)
                PRFULL.(X,WHO(3)...M2,ON,WHO,$ RESETTING TIMUSD AT 'X$,
          1       DATE,X,TIME,$.$)
                PCTL.(1)
          R *
          R *    M1416 4301 ON 800251 RESETTING TIMUSD AT 12/31 2359.1.
          R *
          R *
          R * GO NON-INTERRUPTABLE, RENAME PRESENT TIMUSD TIMACC TO
          R * DATE-TIME, SETFIL A NEW ONE, MOVFIL THE OLD ONE TO MY
          R * DIRECTORY, GET ALL TAU VECTORS AND PROBNO-PROGNO'S.
          R *
                NONINT.
                DATE = RJUST.(DATE)
                CHFILE.(TU,TA,20K,DATE,TIME)
                SETFIL.(TU,TA,DAYTIM,DATELU,120K,2)
                MOVFIL.(DATE,TIME,ME(1),ME)
                GETARY.(TAULOC,B5(B5+LEN)...LEN)
                GETPRB.
          R *
          R *  RESET ALL TIME USED IN CORE A TO ZERO
          R *
                THROUGH MON1, FOR I = 0,1,I.G.LEN
MON1            SLOC.(GLOC.(TAULOC+I).A.77776K7,TAULOC+I)
                INT.
          R *
          R *
                ATTACH.(ME(1),ME)
                LEN = N+1
                TU = DATE
                TA = TIME
                STATUS = $RW$
MON2            READTU.(PROBN(PROBN),PROGN(PROGN),N,MONEOF)
                UPSHFT.
                WRWAIT.(TU,TA,RELLOC,TUCARD(27)...28)
                TRANSFER TO MON2
          R *
          R *  ALL USERS WHICH WERE FOUND IN TIMUSD HAVE BEEN UPDATED,
          R *  NOW CREATE ADDITIONAL CARDS FOR THOSE NOT FOUND.
          R *
MONEOF          THROUGH MON3, FOR J = 0,1,J.G.27
MON3            TUCARD(J) = $$
                BFOPEN.(W,TU,TA,B1(B1+432),B2(B2+432),B3(B3+432),IOERR)
                THROUGH MON4, FOR I = 0,1,I.G.N
                WHENEVER PROBN(PROBN+I) .NE. 0
                  TUCARD(27) = PROBN(PROBN+I)
                  TUCARD(26) = PROGN(PROGN+I)
                  TUCARD(13) = DATE
                  TUCARD(12) = TIME
                  UPSHFT.
                  BFWRIT.(TU,TA,TUCARD(27)...28,IOERR)
                END OF CONDITIONAL
MON4            CONTINUE
                BFCLOS.(TU,TA,IOERR)
                UNLINK.(N1,N2,NULL.)
                CHFILE.(N1,N2,1,M0,M0,NULL.)
                DELFIL.(N1,N2,NULL.)
                CHFILE.(TU,TA,124K,N1,N2)
              END OF CONDITIONAL
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            PATCH
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
PATCH     R * PATCH CORE A
          R *
          R * USAGE:  ADMIN PATCH LOC -DELTA- LHALF RHALF
          R * WHERE 'LOC' IS EITHER AN OCTAL LOCATION, COMMON VARIABLE,
          R * OR ENTRY POINT.  DELTA MAY BE ' '+' OR '-' LENGTH'.
          R * (IF LENGTH ENDS WITH A '.', IT IS ASSUMED TO BE
          R * DECIMAL, OTHERWISE, OCTAL.)
          R *
            EQUIVALENCE (T0,UPATSW), (T1,NAMESW), (T2,DELTA), (T3,LOC)
            EQUIVALENCE (T4,LHALF), (T5,RHALF), (T6,TEST), (T7,KEYS)
            EQUIVALENCE (TUCARD,PATMES)
            DIMENSION PATMES(2)
            BOOLEAN UPATSW,NAMESW
          R *
            DEFINE UNARY OPERATOR .ENK., PRECEDENCE HIGHER THAN .LS.
            MODE STRUCTURE .ENK. 1 TO 1
       XEC      =76000000004K
       STQ      B
       OUT      MQ
       END
          R *
            OR WHENEVER COMBUF(M) .E. $ PATCH$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(FMT3...100)
                VECTOR VALUES FMT3 =
          1   $ 'UADMIN PATCH 'LLOC -DELTA- LHALF RHALF$,
          2   $'* WHERE '=LOC'= IS EITHER AN OCTAL LOCATION, COMMON V$,
          3   $ARIABLE, '* OR AN ENTRY POINT.  '1 DELTA MAY BE '=+'= $,
          4   $OR '=-'= LENGTH.'* ('1IF LENGTH ENDS WITH A '=.'=, IT $,
          5   $IS ASSUMED DECIMAL, OTHERWISE, OCTAL.)$,777777777777K
              OTHERWISE
PAT1            WHENEVER COMBUF(M) .E. FENCE, TRANSFER TO ERR2
                WHENEVER ZEL.(COMBUF(M)).A.$YYYYYY$ .E. 0
                  NAMESW = 0B
                  LOC = BCOCT.(COMBUF(M))
                OTHERWISE
                  NAMESW = 1B
                  PATMES = BZ57.(COMBUF(M))
                  WHENEVER .NOT.UPATSW, PATMES(1) = NULLS
                  PATMES(2) = NULLS
                  LOC = COMLOC.(LJUST.(COMBUF(M)),PAT2)
                  TRANSFER TO PAT3
PAT2              LOC = ENTRY.(COMBUF(M))
                END OF CONDITIONAL
PAT3            M = M+1
          R *
          R *  TEST FOR THE DELTA OPTION (ON PATCH ONLY)
          R *
                WHENEVER UPATSW, TRANSFER TO PAT4
                WHENEVER
          1       (COMBUF(M).E.$     +$ .OR. COMBUF(M).E.$     -$)
          2       .AND. ZEL.(COMBUF(M+1)).A.$     0$.E.0
                  WHENEVER COMBUF(M+1).A.77K .E. $00000.$
                    DELTA = BCDEC.(COMBUF(M+1).RS.6)
                  OR WHENEVER ZEL.(COMBUF(M+1)).A.$YYYYYY$ .NE. 0
                    DELTA = BCDEC.(COMBUF(M+1))
                  OTHERWISE
                    DELTA = BCOCT.(COMBUF(M+1))
                  END OF CONDITIONAL
                  WHENEVER COMBUF(M).E.$     -$, DELTA = -DELTA
                  LOC = LOC + DELTA
                  PATMES(1) = (COMBUF(M).LS.24).V.60575757K
                  PATMES(2) = BZ57.(COMBUF(M+1))
                  M = M+2
                END OF CONDITIONAL
PAT4            WHENEVER UPATSW, LOC = LOC + USER
                WHENEVER .NOT. NAMESW
                  PATMES = BZ57.(OCABC.(LOC))
                  PATMES(1) = NULLS
                  PATMES(2) = NULLS
                END OF CONDITIONAL
                LHALF = COMBUF(M)
                RHALF = COMBUF(M+1)
                M = M+2
                WHENEVER LHALF.V.RHALF .E. FENCE, TRANSFER TO ERR2
                WHENEVER COMBUF(M).NE.FENCE, TRANSFER TO ERR1
                TEST = GLOC.(LOC)
                WHENEVER LHALF.E.STAR, LHALF = OCLBC.(TEST)
                WHENEVER RHALF.E.STAR, RHALF = OCRBC.(TEST)
                LHALF = ZEL.(LHALF)
                RHALF = ZEL.(RHALF)
                WHENEVER (LHALF.V.RHALF).A.$YYYYYY$.NE.0,
          1          TRANSFER TO ERR6
PATTST          WHENEVER .ENK.KEYS.A.KEY22 .NE. KEY22 .AND.
          1          WHO.NE.$(FIB)$
                  GETTM.(DATE,TIME)
                  PRFULL.($'R'1KEY 22 NOT SET AT 'X$,TIME,BLACK)
                  SNOOZE.(10,SLPCMD(2))
                  TRANSFER TO PATTST
                END OF CONDITIONAL
                PCTL.(3)
                PRFULL.(X,WHO(3)...M2,ON,WHO,$ PATCHING 'X$,PATMES...3,
          1    $'L FROM '8$,OCLBC.(TEST),OCRBC.(TEST),$ TO '8$,
          2    LHALF,RHALF,$.$)
                PCTL.(1)
          R *
          R *  M1416 4301 ON 800280 PATCHING RCODE(USER) FROM X TO Y
          R *  M1416 4301 ON 800280 PATCHING QUANTM FROM X TO Y
          R *  M1416 4301 ON 800280 PATCHING SLPTIM + 15. FROM X TO Y
          R *  M1416 4301 ON 800280 PATCHING 76125 FROM X TO Y
          R *
                SLOC.((BCOCT.(LHALF).LS.18).V.BCOCT.(RHALF),LOC)
              END OF CONDITIONAL
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            PB
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
PB        R * ASSIGN A PERCENTAGE OF THE CPU TIME TO A USER
          R *
          R * USAGE:  ADMIN PB N USER (N = THE PERCENTAGE)
          R *
            EQUIVALENCE (T0,PB)
          R *
            OR WHENEVER COMBUF(M) .E. $    PB$
              M = M+1
              PB = BCDEC.(COMBUF(M))
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(ADMIN...2,CURCOM.(0),$ 'LN USER$)
              OR WHENEVER ZEL.(COMBUF(M)).A.$$ .NE. 0 .OR. PB.G.100
                TRANSFER TO ERR0
              OTHERWISE
                M = M+1
                GETUSR.(PB0,ERR4,ERR5)
PB0             PCTL.(3)
                PRFULL.(X,WHO(3)...M2,ON,WHO,
          1        $ SETTING PERCENTAGE OF 'X$,
          2        PROB...2,$ TO 'X$,BZ57.(DEFBC.(PB)),$.$)
                PCTL.(1)
          R *
          R *      M1416 4301 ON 800251 SETTING PERCENTAGE OF
          R *      M1416 9324 TO 15.
          R *
                SLOC.(PB,COMMON.($PB$)+USR)
                SLOC.(GLOC.(COMMON.(TIMNOW)),COMMON.(STRTIM)+USR)
                SLOC.(0,COMMON.(WRKTIM)+USR)
              END OF CONDITIONAL
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            PRNTON
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
PRNTON    R * PRINT A MESSAGE (OR FILE) ONLINE
          R *
          R * USAGE:  ADMIN PRNTON -NAME1 NAME2-
          R *
            OR WHENEVER COMBUF(M) .E. $PRNTON$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(ADMIN...2,CURCOM.(0),$ 'L-NAME1 NAME2-$)
              OTHERWISE
                PRNTON.(COMBUF(M),COMBUF(M+1))
              END OF CONDITIONAL
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            RDTIMU
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
RDTIMU    R * FIND THE TIME USED BY A USER
          R *
          R * USAGE:  ADMIN RDTIMU USER -NAME1- -NAME2-
          R *
          R * E'E (T0,N1), (T1,N2) (T6,TAULOC)
            EQUIVALENCE (T2,NOTLIN), (T3,FOUND), (T4,SHFT), (T5,TAU)
            EQUIVALENCE (TUCARD(27),USED(5)), (TUCARD(21),ALTD(5))
            DIMENSION ALTD(0),USED(0)
            BOOLEAN NOTLIN, FOUND
          R *
            OR WHENEVER COMBUF(M) .E. $RDTIMU$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(ADMIN...2,CURCOM.(0),$ '4USER -NAME1- -NAME2-$)
              OTHERWISE
                NOTLIN = 1B
                GETUSR.(RTU0,RTU1,ERR5)
RTU0            NOTLIN = 0B
RTU1            WHENEVER COMBUF(M) .E. FENCE
                  NONINT.
                  ATTACH.(M1416,CMFL02)
                  TRANSFER TO RTU2
                END OF CONDITIONAL
                TU = COMBUF(M)
                M = M+1
                WHENEVER COMBUF(M) .NE. FENCE
                  TA = COMBUF(M)
                  M = M+1
                END OF CONDITIONAL
                WHENEVER COMBUF(M) .NE. FENCE, TRANSFER TO ERR1
          R *
RTU2            STATUS = R
                READTU.(PROB,PROG,1,RTU3)
                NAME = TUCARD(25)
                FOUND = 1B
                BFCLOS.(TU,TA,RTU3)
          R *
RTU3            INT.
                WHENEVER NOTLIN .AND. .NOT.FOUND
                  PRFULL.($'1NEVER HEARD OF 'X$,PROB...2)
                  TRANSFER TO OUT
                OR WHENEVER NOTLIN
                  THROUGH RTU4, FOR I = 1,1,I.G.5
                    ALTD(I) = 0
                    USED(I) = BCDEC.(TUCARD(10-I))*60
RTU4              CONTINUE
                OTHERWISE
                  TAULOC = COMMON.(TAU5)
                  THROUGH RTU5, FOR I = 4,-1,I.L.0
                    TAU = GLOC.(TAULOC+I*(N+1)+USR)
                    USED(5-I) = TAU.A.17777777K
                    ALTD(5-I) = TAU.RS.14
                    WHENEVER ALTD(5-I).NE.0, ALTD(5-I)=ALTD(5-I).V.377K
RTU5                CONTINUE
                END OF CONDITIONAL
                PRFULL.(X,NAME,X,PROB...2)
                THROUGH RTU6, FOR I = 1,1,I.G.5
                WHENEVER ALTD(I).V.USED(I) .NE. 0
                  SHFT = DEFBC.(I).LS.12.V.$0000  $
                  PRFULL.(BZEL.(SHFT),BZEL.(MINS.(ALTD(I))),
          1         BZEL.(MINS.(USED(I))))
                END OF CONDITIONAL
RTU6            CONTINUE
                WHENEVER FOUND, PRFULL.($'1LAST LOGOUT 'X$,
          1         TUCARD(13).A.7777K8.V.$00/00$.V.
          2         (TUCARD(13).RS.6.A.7777K2),
          3         TUCARD(12),$ FROM $,X,TUCARD(11),$.$)
          R *
          R *     LAST LOGOUT 12/31 1832.1 FROM 800251.
          R *
                WHENEVER .NOT.NOTLIN, PRFULL.($'1NOW ON UNIT 'X$,
          1     GLOC.(COMMON.(UNITID)+USR),$ LINE $,BZ57.(DEFBC.(USR)))
          R *
          R *      NOW ON UNIT 800251 LINE 31
          R *
              END OF CONDITIONAL
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            SETTAU
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
SETTAU    R * SET/RESET TAU VECTORS IN CORE A FOR A USER
          R *
          R * USAGE:  ADMIN SETTAU SHFT ALTD USED USER
          R *
          R * E'E (T4,SHFT), (T5,TAU), (T6,TAULOC)
          R * E'E (TUCARD(27),USED(5)), (TUCARD(21),ALTD(5))
            EQUIVALENCE (OUSED,USED(1)), (OALTD,ALTD(1))
            EQUIVALENCE (NUSED,USED(2)), (NALTD,ALTD(2))
          R *
            OR WHENEVER COMBUF(M) .E. $SETTAU$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(ADMIN...2,CURCOM.(0),$ 'LSHIFT ALTD USED USER$)
              OTHERWISE
                SHFT = COMBUF(M)
                ALTD = COMBUF(M+1)
                USED = COMBUF(M+2)
                M = M+3
                WHENEVER SHFT.V.ALTD.V.USED .E. FENCE, TRANSFER TO ERR2
                SHFT = BCDEC.(SHFT)
                WHENEVER SHFT.E.0 .OR. SHFT.G.5, TRANSFER TO ERR0
                GETUSR.(SET0,ERR4,ERR5)
SET0            TAULOC = COMMON.(TAU1) - (SHFT-1)*(N+1) + USR
                TAU = GLOC.(TAULOC)
                OUSED = TAU.A.17777777K
                OALTD = TAU.RS.14.V.377K
          R *
                WHENEVER USED .E. STAR
                  NUSED = OUSED
                OTHERWISE
                  WHENEVER ZEL.(USED).A.$$.NE.0, TRANSFER TO ERR0
                  NUSED = BCDEC.(USED) * 3600
                END OF CONDITIONAL
          R *
                WHENEVER ALTD .E. STAR
                  NALTD = OALTD
                OTHERWISE
                  WHENEVER ZEL.(ALTD).A.$$ .NE. 0, TRANSFER TO ERR0
                  NALTD = BCDEC.(ALTD) * 3600
                END OF CONDITIONAL
          R *
                PCTL.(3)
                PRFULL.(X,WHO(3)...M2,ON,WHO,$ SETTING '3TAU'X$,
          1     BZ57.(DEFBC.(SHFT)),$ OF'X$,PROB...2,$ FROM $,
          2     BZ57.(DEFBC.(OALTD/3600)),BL,BZ57.(DEFBC.(OUSED/3600)),
          3     $ TO '8$,BZ57.(DEFBC.(NALTD/3600)),BL,
          4     BZ57.(DEFBC.(NUSED/3600)),$.$)
                  PCTL.(1)
          R *
          R *     M1416 3579 ON 800251 SETTING TAU1 OF M1416 4301
          R *          FROM 600 10 TO 300 30.
          R *
                SLOC.(NALTD.LS.14.A.77776K7.V.NUSED.A.17777777K,TAULOC)
          R *
              END OF CONDITIONAL
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            SPY
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
SPY       R * SPY ON ANOTHER USER
          R *
          R * USAGE:  ADMIN SPY USER
          R *
            EQUIVALENCE (OLDM,T0)
          R *
            OR WHENEVER COMBUF(M) .E. $   SPY$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.($'UADMIN SPY 'LUSER$)
              OTHERWISE
                OLDM = M
SPY1            GETUSR.(ERR3,SPY3,ERR5)
                PRFULL.($'1USER FOUND:'X$,PROB...2,$ LINE $,
          1     BZ57.(DEFBC.(USR)))
                ADOPT = COMMON.(ADOPT)
                SLOC.(3K5.V.USR,ADOPT+USER)
                SLOC.(GLOC.(ADOPT+USR).V.7000003K5,ADOPT+USR)
SPY2            SNOOZE.(1800,SLPCMD(2))
          R *  ... SLEEP FOR 30 MINUTES, THEN CALL SLEEP AGAIN.
                TRANSFER TO SPY2
          R *
SPY3            GETTM.(DATE,TIME)
                PRFULL.(X,PROB...2,$ IS NOT LOGGED IN - 'X$,TIME)
                SNOOZE.(15,SLPCMD(2))
                M = OLDM
                TRANSFER TO SPY1
              END OF CONDITIONAL
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                             SQZUFD
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
SQZUFD    R * COMPACT A USER U.F.D ELIMINATING HOLES
          R *
          R * USAGE:  ADMIN SQZUFD USER1 USER2 ...
          R *    ANY USER MAY BE FOLLOWED BY '(DRUM)' OR '(DISK)' TO
          R *    INDICATE WHERE THE FINAL UFD IS TO RESIDE.
          R *
            EQUIVALENCE (T0,N1), (T1,N2), (T2,NSTICK), (T3,STICKY)
            EQUIVALENCE (TUCARD(8),LENGTH), (TUCARD(5),DEV),
          1   (TUCARD(27),BUFF)
            DIMENSION BUFF(0)
          R *
            OR WHENEVER COMBUF(M) .E. $SQZUFD$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(FMT5...100)
                VECTOR VALUES FMT5 =
          1  $ 'UADMIN SQZUFD 'LUSER1 USER2 ... $,
          2  $'*  USER MAY BE FOLLOWED BY '='4(DISK)'= OR '='4(DRUM)'=$,
          3  $'*  TO INDICATE WHERE THE FINAL UFD IS TO RESIDE.$,
          4  777777777777K
              OTHERWISE
                GETBUF.(B1,432)
                GETBUF.(B2,432)
                GETBUF.(B3,432)
                GETBUF.(B4,432)
                GETBUF.(B5,432)
                FSTST = ENTRY.(FSTST)
                NSTICK = ENTRY.(SAVING) + 1
                STICKY = NSTICK + 6
                NSTICK = GLOC.(NSTICK)*13
                ATTACH.(MFD,FILE)
                FERRTN.(SQZERR)
          R *
SQZ1            GETUSR.(ERR3,SQZ2,ERR5)
SQZ2            NONINT.
                FSTATE.(PROB,PROG,LENGTH...8,NOUFD)
                TRANSFER TO SQZUFD
NOUFD           PRFULL.($'R'X$,PROB...2,$ NOT FOUND.'B$)
                TRANSFER TO SQZOUT
          R *
SQZUFD          WHENEVER COMBUF(M) .E. $(DRUM)$
                  DEV = 1
                  M = M+1
                OR WHENEVER COMBUF(M) .E. $(DISK)$
                  DEV = 2
                  M = M+1
                END OF CONDITIONAL
                THROUGH SQZ3, FOR I = 0,13,I.G.NSTICK
                  N1 = GLOC.(STICKY+I)
                  N2 = GLOC.(STICKY+I+1)
                  WHENEVER N1 .E. PROB .AND. N2 .E. PROG
                    INT.
                    PRFULL.(RED,X,PROB...2,
          1         $ HAS INFORMATION IN THE STICKIES.'B$)
                    TRANSFER TO SQZOUT
                  END OF CONDITIONAL
SQZ3            CONTINUE
                SLOC.(FENCE,FSTST)
          R *
          R *  OPEN PROB PROG, DELETE PREVIOUS PROG PROB IF ANY,
          R *  COPY PROB PROG INTO PROG PROB GETTING RID OF 0 ENTRIES.
          R *
                ALLOT.(2,32767)
                ALLOT.(1,32767)
                BFOPEN.(R,PROB,PROG,B1(B1+432),B2(B2+432),M0,SQZERR)
                CHFILE.(PROG,PROB,1,M0,M0,NULL.)
                DELFIL.(PROG,PROB,NULL.)
                BFOPEN.(W,PROG,PROB,B3(B3+432),B4(B4+432),B5(B5+432),
          1     SQZERR)
                BFREAD.(PROB,PROG,BUFF...3,SQZEOF,M0,SQZERR)
                BFWRIT.(PROG,PROB,BUFF...3,SQZERR)
SQZ5            BFREAD.(PROB,PROG,BUFF...7,SQZEOF,M0,SQZERR)
                WHENEVER BUFF.V.BUFF(M1).NE.0,
          1       BFWRIT.(PROG,PROB,BUFF...7,SQZERR)
                TRANSFER TO SQZ5
          R *
SQZEOF          BFCLOS.(PROB,PROG,SQZERR)
                BFCLOS.(PROG,PROB,SQZERR)
SQZ6            CHFILE.(PROB,PROG,1)
                DELFIL.(PROB,PROG)
                CHFILE.(PROG,PROB,104K,PROB,PROG)
          R *
          R *  IF UFD IS TO BE ON THE DRUM, USE THE COPY ROUTINE
          R *  TO TRANSFER IT.
          R *
                WHENEVER DEV .E. 1
                DEV = 2
                OPEN.(R,PROB,PROG)
                OPEN.(W,PROG,PROB,0,1)
                BUFFER.(PROG,PROB,B4(B4+432)...432)
                COPY.(PROB,PROG,PROG,PROB,B1(B1+432),B2(B2+432),
          1     B3(B3+432),432,SQZERR)
                CLOSE.(PROB,PROG)
                CLOSE.(PROG,PROB)
                TRANSFER TO SQZ6
                END OF CONDITIONAL
          R *
SQZOUT          RESETF.
                SLOC.(0,FSTST)
                INT.
                WHENEVER COMBUF(M).NE. FENCE, TRANSFER TO SQZ1
                TRANSFER TO OUT
          R *
SQZERR          PRDIAG.
                TRANSFER TO SQZOUT
              END OF CONDITIONAL
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            UPATCH
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
UPATCH    R * PATCH PRESENT USERS ARRAY ENTRY IN CORE A
          R *
          R * USAGE:  ADMIN UPATCH LOC LHALF RHALF
          R *
          R * E'E (T0,UPATSW), (TUCARD,PATMES)
          R *
            OR WHENEVER COMBUF(M) .E. $UPATCH$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(ADMIN...2,CURCOM.(0),$ 'LLOC LHALF RHALF$)
              OTHERWISE
                UPATSW = 1B
                PATMES(1) = $(USER)$
                TRANSFER TO PAT1
              END OF CONDITIONAL
          R *
          R *
          R *
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                          UPDATE
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *
UPDATE    R * UPDATE CMFL02 WITH ACCOUNTING FILES
          R *
          R * USAGE:   ADMIN UPDATE N1 -N2- -N3- -N4-
          R *
          R E'E (T0,N1), (T1,N2), (T2,N3), (T3,N4), (T7,MODE)
          R
            OR WHENEVER COMBUF(M) .E. $UPDATE$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(ADMIN...2,CURCOM.(0),$ N1 -N2- -N3- -N4-$)
              OTHERWISE
                N1 = COMBUF(M)
                N2 = COMBUF(M+1)
                N3 = COMBUF(M+2)
                N4 = COMBUF(M+3)
                WHENEVER N2 .E. FENCE
                  N2 = TA
                  N3 = N1
                  N4 = N2
                OR WHENEVER N3 .E. FENCE
                  N3 = N1
                  N4 = N2
                OR WHENEVER N4 .E. FENCE
                  N4 = N2
                OR WHENEVER N1 .E. FENCE
                  TRANSFER TO ERR2
                OR WHENEVER COMBUF(M+4).NE.FENCE
                  M = M+4
                  TRANSFER TO ERR1
                END OF CONDITIONAL
          R *
                WHENEVER ME(1).E.M1416 .AND. ME.E.CMFL02 .AND.
          1       N3.E.N1 .AND. N4.E.N2, TRANSFER TO ERR0
                CHKPRV.(RPRVBT)
          R *
                GETBUF.(B1,432)
                GETBUF.(B2,432)
                GETBUF.(B3,432)
                GETBUF.(B4,432)
                OPEN.(R,N1,N2)
                ATTACH.(M1416,CMFL02)
                NONINT.
                CHFILE.(DATE,TIME,1,M0,M0,NULL.)
                DELFIL.(DATE,TIME,NULL.)
                OPEN.(W,DATE,TIME,120K)
                BUFFER.(DATE,TIME,B4(B4+432)...432)
                COPY.(N1,N2,DATE,TIME,B1(B1+432),B2(B2+432),B3(B3+432),
          1           432,IOERR)
                CLOSE.(DATE,TIME)
                CLOSE.(N1,N2)
                MODE = 120K
                FSTATE.(N3,N4,TUCARD(1)...2,UPD1)
                MODE = TUCARD.A.777K
UPD1            CHFILE.(N3,N4,1,M0,M0,NULL.)
                DELFIL.(N3,N4,NULL.)
                CHFILE.(DATE,TIME,MODE,N3,N4)
                INT.
              END OF CONDITIONAL
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                            WRITE
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
WRITE     R * WRITE A MESSAGE AT A USER
          R *
          R * USAGE: ADMIN WRITE USER
          R *
            OR WHENEVER COMBUF(M) .E. $ WRITE$
              M = M+1
              WHENEVER COMBUF(M) .E. HELP
                PRFULL.(ADMIN...2,CURCOM.(0),$ 'LUSER$)
              OTHERWISE
                GETUSR.(ERR3,ERR4,ERR5)
                SETFUL.
                WRITE.(USR)
                SETBCD.
              END OF CONDITIONAL
          R *
          R *
          R *
            OTHERWISE
              WHENEVER M.E.0
                M = 1
                TRANSFER TO USEROK
              OTHERWISE
                PRFULL.($'R'X$,COMBUF(M),$ IS NOT A VALID FUNCTION.'B$)
              END OF CONDITIONAL
            END OF CONDITIONAL
OUT         RESETF.
            ATTACH.(ME(1),ME,EXITM.)
            EXITM.
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                    ERROR PROCESSOR
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *
          R *
IOERR       PRFULA.(RED)
            PRDIAG.
            PRFULA.(BLACK)
            TRANSFER TO OUT
          R *
ERR0        PRFULL.($'R'1ILLEGAL USAGE.'B$)
            TRANSFER TO OUT
          R *
ERR1        PRFULL.($'R'1ILLEGAL ARGUMENT: 'X$,COMBUF(M),BLACK)
            TRANSFER TO OUT
          R *
ERR2        PRFULL.($'R'1MISSING ARGUMENT(S)'B$)
            TRANSFER TO OUT
          R *
ERR3        PRFULL.($'R'1MISSING OR ILLEGAL USER SPECIFICATION.'B$)
            TRANSFER TO OUT
          R *
ERR5        PRFULL.($'R'1LINE '8$,BZ57.(DEFBC.(USR)),$ IS EMPTY.'B$)
            TRANSFER TO OUT
          R *
ERR4        PRFULL.(RED,X,PROB...2,$ IS NOT LOGGED IN.'B$)
            TRANSFER TO OUT
          R *
ERR6        PRFULL.(RED,LHALF,RHALF,$ NOT OCTAL.'B$)
            TRANSFER TO OUT
          R *
ERR7        PRFULL.($'R'1SYSTEM ERROR: FULL RETURN FROM '6ENTLIN.'B$)
            TRANSFER TO OUT
          R *
          R *
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *                    INTERNAL FUNCTIONS
          R *
          R * **********************************************************
          R * **********************************************************
          R * **********************************************************
          R *
          R *
          R *
CHKPRV    R * CHECK FOR NECESSARY PRIVILEGES.
          R *
          R * USAGE:  CHKPRV.(CODE)
          R *
            INTERNAL FUNCTION (CODE)
            ENTRY TO CHKPRV.
            WHENEVER RCODE.A.CODE.E.CODE, FUNCTION RETURN
            PRFULL.($'R'1INSUFFICIENT PRIVILEGES.  '1NEED AT LEAST '8$,
          1   BZ57.(OCRBC.(CODE)),BLACK)
            TRANSFER TO OUT
            END OF FUNCTION
          R *
          R *
          R *
COMMON    R * RETURN THE VALUE (OR LOCATION) OF A COMMON VARIABLE
          R *
          R * USAGE:   COMMON.(SYMBOL)
          R *
            INTERNAL FUNCTION (SYMBOL)
            ENTRY TO COMMON.
            FUNCTION RETURN COMLOC.(LJUST.(SYMBOL),COMERR)
          R *
COMERR      PRFULL.($'R'X$,BZ57.(RJUST.(SYMBOL)),$ WAS NOT FOUND.'B$)
            TRANSFER TO OUT
          R *
          R *
          R *
ENTRY     R * RETURN THE LOCATION OF A CORE A ENTRY
          R *
          R * USAGE:   ENTRY.(SYMBOL)
          R *
            ENTRY TO ENTRY.
            FUNCTION RETURN ACORE.(LJUST.(SYMBOL),COMERR).RS.18
            END OF FUNCTION
          R *
          R *
          R *
CURCOM    R * GET THE NAME OF THE CURRENT FUNCTION
          R * WITH LEADING BLANKS STIRPPED OFF.
          R *
            INTERNAL FUNCTION CURCOM.(X) = BZ57.(COMBUF(M-1))
          R *
          R *
          R *
INT       R *  RESET THE NON INTERUPT BIT
          R *
            INTERNAL FUNCTION
            ENTRY TO INT.
            SLOC.(GLOC.(USROPT).A..N.NINTBT,USROPT)
            FUNCTION RETURN
          R *
          R *
          R *
NONINT    R *  SET THE NON-INTERUPT BIT
          R *
            ENTRY TO NONINT.
            SLOC.(GLOC.(USROPT).V.NINTBT,USROPT)
            FUNCTION RETURN
            END OF FUNCTION
          R *
          R *
          R *
GETUSR    R * GET A USER NUMBER, PROBNO, PROGNO AND NAME FROM
          R * THE 'USER' SPECIFICATION.
          R * WRITTEN BY D.A. ANDERSON
          R *
          R * USAGE:  GETUSR.(NONE,NOTIN,LNMTY)
          R * WHERE NONE = LOC TO TRANSFER IF NO USER SPECIFIED
          R *      NOTIN = LOC TO TRANSFER IF PROB-PROG GIVEN BUT NOT IN
          R *      LNMTY = LOC TO TRANSFER IF USER NO. GIVEN BUT NOT IN
          R *
            INTERNAL FUNCTION (NONE,NOTIN,LNMTY)
            STATEMENT LABEL NONE,NOTIN,LNMTY
            ENTRY TO GETUSR.
          R *
            WHENEVER COMBUF(M).E.FENCE
               USR = USER
               GTUSR.(LNMTY)
               TRANSFER TO NONE
            OR WHENEVER ZEL.(COMBUF(M)).A.$$.E.0
               USR = BCDEC.(COMBUF(M))
               WHENEVER USR.G.N, TRANSFER TO ERR3
               WHENEVER USR.E.0
                  PROB = $ BACKG$
                  PROG = $ROUND$
                  NAME = $$
               OTHERWISE
                  GTUSR.(LNMTY)
               END OF CONDITIONAL
               M = M+1
            OR WHENEVER COMBUF(M) .E. STAR
               USR = USER
               GTUSR.(LNMTY)
               M = M+1
            OTHERWISE
               PROB = REPROB.(COMBUF(M))
               M = M+1
               WHENEVER COMBUF(M).E.FENCE, TRANSFER TO ERR3
               PROG = COMBUF(M)
               M = M+1
               GETPRB.
GTUSR1         THROUGH GTUSR1, FOR USR = 1,1,USR.G.N .OR.
          1       (PROB.E.PROBN(PROBN+N-USR+1).AND.
          2        PROG.E.PROGN(PROGN+N-USR+1))
               WHENEVER USR.G.N
                  USR = 0
                  NAME = $$
                  TRANSFER TO NOTIN
               END OF CONDITIONAL
               NAME = GLOC.(COMMON.(UNAME)+USR)
            END OF CONDITIONAL
            FUNCTION RETURN
            END OF FUNCTION
          R *
          R *
          R *
          R *
GTUSR     R * GIVEN A LINE NO., SETUP PROB,PROG AND NAME
          R *
          R * USAGE   GTUSR.
          R *
            INTERNAL FUNCTION (LNMTY)
            ENTRY TO GTUSR.
          R *
            PROB = GLOC.(COMMON.($PROBN$)+USR)
            WHENEVER PROB.E.0
              M = M+1
              TRANSFER TO LNMTY
              END OF CONDITIONAL
            PROG = GLOC.(COMMON.($PROGN$)+USR)
            NAME = GLOC.(COMMON.(UNAME)+USR)
            FUNCTION RETURN
            END OF FUNCTION
          R *
          R *
          R *
          R *
GETPRB    R * ROUTINE TO SNATCH THE PROBN AND PROGN ARRAYS
          R *
          R * USAGE:  GETPRB.
          R *
            BOOLEAN PRBSW
            VECTOR VALUES PRBSW = 1B
            INTERNAL FUNCTION
            ENTRY TO GETPRB.
          R *
            WHENEVER PRBSW
              PRBSW = 0B
              GETBUF.(PROBN,N)
              GETBUF.(PROGN,N)
            END OF CONDITIONAL
            GETARY.(COMMON.($PROBN$)+1,PROBN(PROBN+N)...N)
            GETARY.(COMMON.($PROGN$)+1,PROGN(PROGN+N)...N)
            FUNCTION RETURN
            END OF FUNCTION
          R *
          R *
          R *
READTU    R * ROUTINE TO READ TIMUSD TIMACC LOOKING FOR PROB(S)/PROG(S)
          R *
          R * USAGE:  READTU.(PROB(0),PROG(0),COUNT,EOF)
          R *
            BOOLEAN FRSTSW
            VECTOR VALUES FRSTSW = 1B
            INTERNAL FUNCTION (PRB,PRG,COUNT,EOF)
            STATEMENT LABEL EOF
            ENTRY TO READTU.
            WHENEVER FRSTSW
               FRSTSW = 0B
               GETBUF.(B1,432)
               GETBUF.(B2,432)
               GETBUF.(B3,432)
               BFOPEN.(STATUS,TU,TA,B1(B1+432),B2(B2+432),M0,IOERR)
               BUFFER.(TU,TA,B3(B3+432)...432)
               RELLOC = 1
            OTHERWISE
RDTU1          RELLOC = RELLOC + 28
            END OF CONDITIONAL
            BFREAD.(TU,TA,TUCARD(27)...28,BEOF,M0,IOERR)
            THROUGH RDTU2, FOR I = 0,1,I.G.COUNT
RDTU2       WHENEVER PRB(I).E.TUCARD(27) .AND. PRG(I).E.TUCARD(26),
          1        FUNCTION RETURN
            TRANSFER TO RDTU1
          R *
BEOF        BFCLOS.(TU,TA,IOERR)
            TRANSFER TO EOF
          R *
            END OF FUNCTION
          R *
          R *
          R *
UPSHFT    R * UPDATE TUCARD WITH TIME USED FROM B5 TAU VECTORS
          R *
          R * USAGE:  UPSHFT.
          R *
            INTERNAL FUNCTION
            ENTRY TO UPSHFT.
            THROUGH UPS1, FOR J = 0,1,J.G.4
              WHENEVER TUCARD(27).NE.$ C0056$, TUCARD(9-J) = 0
              TUCARD(9-J) = DEFBC.( B5(B5+J*LEN+I).A.17777777K/60 +
          1                      BCDEC.(TUCARD(9-J)))
UPS1        CONTINUE
            PROBN(PROBN+I) = 0
            FUNCTION RETURN
            END OF FUNCTION
          R *
          R *
          R *
            END OF PROGRAM
